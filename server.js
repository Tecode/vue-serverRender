const fs = require('fs');
const path = require('path');
const LRU = require('lru-cache');
const express = require('express');
const favicon = require('serve-favicon');
const compression = require('compression');
const resolve = file => path.resolve(__dirname, file);
const {createBundleRenderer} = require('vue-server-renderer');
const useragent = require('express-useragent');
const axios = require('axios');
const cookieParser = require('cookie-parser');
const mysql = require('mysql');
let status = true;
// 创建mysql数据库连接
const pool  = mysql.createPool({
	host: "119.29.249.33",
	user: "aming",
	password: "5101259927x",
	database: "aming_site_db"
});

const isProd = process.env.NODE_ENV === 'production';
const useMicroCache = process.env.MICRO_CACHE !== 'false';
const serverInfo =
`express/${require('express/package.json').version} ` +
`vue-server-renderer/${require('vue-server-renderer/package.json').version}`;

const app = express();

const template = fs.readFileSync(resolve('./src/index.template.html'), 'utf-8');
function createRenderer(bundle, options) {
	// https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
	return createBundleRenderer(bundle, Object.assign(options, {
		template,
		// for component caching
		cache: LRU({
			max: 1000,
			maxAge: 1000 * 60 * 15
		}),
		// this is only needed when vue-server-renderer is npm-linked
		basedir: resolve('./dist'),
		// recommended for performance
		runInNewContext: false
	}))
}

let renderer;
let readyPromise;
if (isProd) {
	// In production: create server renderer using built server bundle.
	// The server bundle is generated by vue-ssr-webpack-plugin.
	const bundle = require('./dist/vue-ssr-server-bundle.json');
	// The client manifests are optional, but it allows the renderer
	// to automatically infer preload/prefetch links and directly add <script>
	// tags for any async chunks used during render, avoiding waterfall requests.
	const clientManifest = require('./dist/vue-ssr-client-manifest.json');
	renderer = createRenderer(bundle, {
		clientManifest
	})
} else {
	// In development: setup the dev server with watch and hot-reload,
	// and create a new renderer on bundle / index template update.
	readyPromise = require('./build/setup-dev-server')(app, (bundle, options) => {
		renderer = createRenderer(bundle, options)
	})
}

const serve = (path, cache) => express.static(resolve(path), {
	maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0
});

app.use(cookieParser());
app.use(useragent.express());
app.use(compression({threshold: 0}));
app.use(favicon('./public/logo-48.png'));
app.use('/dist', serve('./dist', true));
app.use('/public', serve('./public', true));
app.use('/manifest.json', serve('./manifest.json', true));
app.use('/service-worker.js', serve('./dist/service-worker.js'));
app.use(express.static('files'));
app.use((req, res, next) => {
	if (status) {
		let ip = req.headers['cf-connecting-ip'] || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
		if (ip.substr(0, 7) === "::ffff:") {
			ip = ip.substr(7)
		}
		pool.getConnection(function (err, connection) {
			const sql = `INSERT INTO site_visit_info (platform, browser, isiPad, isiPhone,isAndroid, isMobile, isIE,
		isFirefox,
		isEdge,
		isChrome,
		isSafari,
		isWindows,
		isLinux,
		isMac,
		isUC,
		version,
		timestamp
		) VALUES (
				'${req.useragent.platform}',
				'${req.useragent.browser}',
				'${req.useragent.isiPad}',
				'${req.useragent.isiPhone}',
				'${req.useragent.isAndroid}',
				'${req.useragent.isMobile}',
				'${req.useragent.isIE}',
				'${req.useragent.isFirefox}',
				'${req.useragent.isEdge}',
				'${req.useragent.isChrome}',
				'${req.useragent.isSafari}',
				'${req.useragent.isWindows}',
				'${req.useragent.isLinux}',
				'${req.useragent.isMac}',
				'${req.useragent.isUC}',
				'${req.useragent.version}',
				'${Math.round(new Date().getTime() / 1000)}'
				)`;
			connection.query(sql, function (err, result, fields) {
				connection.release();
				if (err) throw err;
			});
		});
		axios.post(`http://ip.taobao.com/service/getIpInfo.php?ip=${ip}`)
		.then(({data}) => {
			pool.getConnection(function (err, connection) {
				if (err) throw err;
				const sql = `INSERT INTO site_ip_address (country, country_id, region, city, county, ip, timestamp) VALUES (
				'${data.data.country}',
				'${data.data.country_id}',
				'${data.data.region}',
				'${data.data.city}',
				'${data.data.county}',
				'${data.data.ip}',
				'${Math.round(new Date().getTime() / 1000)}'
				)`;
				connection.query(sql, function (err, result) {
					connection.release();
					if (err) throw err;
				});
			});
		})
		.catch((err) => {
			console.log(err.response.data);
		});
	}
	status = !status;
	next();
});
// 模板引擎
app.engine('html', function (filePath, options, callback) {
	fs.readFile(filePath, 'utf8', (err, data) => {
		fs.readFile(`./viewSource/${options.name}`, 'utf8', (err2, data2) => {
			if (err && err2) return callback(new Error(err, err2));
			// 这是一个功能极其简单的模板引擎
			const rendered = data.replace('{{title}}', options.title)
			.replace('{{message}}', data2)
			.replace('{{discript}}', options.discript)
			.replace('{{keyWords}}', options.keyWords)
			.replace('{{sid}}', options.sid);
			return callback(null, rendered);
		});
	});
});
app.set('views', './template'); // 指定视图所在的位置
app.set('view engine', 'html'); // 注册模板引擎
// 访问文章
app.get('/article/:id', (req, res) => {
	pool.getConnection(function (err, connection) {
		if (err) throw err;
		const sql = `SELECT article_title, file_name, article_discript, article_keywords FROM site_article WHERE article_id = ${req.params.id}`;
		connection.query(sql, function (err, result) {
			connection.release();
			if (err) throw err;
			res.render('index', {
				title: result[0]['article_title'],
				name: result[0]['file_name'],
				sid: req.params.id,
				keyWords: result[0]['article_keywords'],
				discript: result[0]['article_discript']});
		});
	});
});

// 1-second microcache.
// https://www.nginx.com/blog/benefits-of-microcaching-nginx/
const microCache = LRU({
	max: 100,
	maxAge: 1000
});

// since this app has no user-specific content, every page is micro-cacheable.
// if your app involves user-specific content, you need to implement custom
// logic to determine whether a request is cacheable based on its url and
// headers.
const isCacheable = req => useMicroCache;

function render(req, res) {
	const s = Date.now();

	res.setHeader("Content-Type", "text/html");
	res.setHeader("Server", serverInfo);

	const handleError = err => {
		if (err && err.code === 404) {
			res.status(404).end('404 | Page Not Found')
		} else {
			// Render Error Page or Redirect
			res.status(500).end('500 | Internal Server Error');
			console.error(`error during render : ${req.url}`);
			console.error(err.stack)
		}
	};

	const cacheable = isCacheable(req);
	if (cacheable) {
		const hit = microCache.get(req.url);
		if (hit) {
			if (!isProd) {
				console.log(`cache hit!`)
			}
			return res.end(hit)
		}
	}

	const context = {
		title: '乐游博客-阿明的博客-站内提供资源分享', // default title
		url: req.url
	};
	renderer.renderToString(context, (err, html) => {
		if (err) {
			return handleError(err)
		}
		res.end(html);
		if (cacheable) {
			microCache.set(req.url, html)
		}
		if (!isProd) {
			console.log(`whole request: ${Date.now() - s}ms`)
		}
	})
}

app.get('*', isProd ? render : (req, res) => {
	readyPromise.then(() => render(req, res))
});

const port = process.env.PORT || 8080;
app.listen(port, () => {
	console.log(`server started at localhost:${port}`)
});
